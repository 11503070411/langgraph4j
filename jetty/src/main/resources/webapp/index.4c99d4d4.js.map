{"mappings":"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","sources":["<anon>","src/lg4j-executor.js"],"sourcesContent":["\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire3bab\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire3bab\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\n\nvar $hNeh9 = parcelRequire(\"hNeh9\");\n\nvar $800sp = parcelRequire(\"800sp\");\n/**\n * Asynchronously fetches data from a given fetch call and yields the data in chunks.\n * \n * @async\n * @generator\n * @param Response - Response object to stream.\n * @yields {Promise<string>} The decoded text chunk from the response stream.\n */ async function* $0ca21e1f1d158660$var$streamingResponse(response) {\n    // Attach Reader\n    const reader = response.body.getReader();\n    while(true){\n        // wait for next encoded chunk\n        const { done: done, value: value } = await reader.read();\n        // check if stream is done\n        if (done) break;\n        // Decodes data chunk and yields it\n        yield new TextDecoder().decode(value);\n    }\n}\nclass $0ca21e1f1d158660$export$2fe88ce002d9c04f extends (0, $800sp.LitElement) {\n    /**\n   * Styles applied to the component.\n   * \n   * @static\n   * @type {Array}\n   */ static styles = [\n        (0, $hNeh9.default),\n        (0, $800sp.css)`\n    .container {\n      display: flex;\n      flex-direction: column;\n      row-gap: 10px;\n    }\n  `\n    ];\n    /**\n   * Properties of the component.\n   * \n   * @static\n   * @type {Object}\n   */ static properties = {\n        url: {},\n        test: {\n            type: Boolean\n        }\n    };\n    /**\n   * Creates an instance of LG4JInputElement.\n   * \n   * @constructor\n   */ constructor(){\n        super();\n        this.test = false;\n        this.formMetaData = {};\n    }\n    /**\n   * Lifecycle method called when the element is added to the document's DOM.\n   */ connectedCallback() {\n        super.connectedCallback();\n        if (this.test) setTimeout(()=>{\n            this.dispatchEvent(new CustomEvent(\"graph\", {\n                detail: `\n            flowchart TD\n            Start --> Stop\n            `,\n                bubbles: true,\n                composed: true,\n                cancelable: true\n            }));\n            this.formMetaData = {\n                input: {\n                    type: \"string\",\n                    required: true\n                }\n            };\n            this.requestUpdate();\n        }, 1000);\n        else this.#init();\n    }\n    async #init() {\n        const initResponse = await fetch(`${this.url}/init`);\n        const initData = await initResponse.json();\n        console.debug(initData);\n        this.dispatchEvent(new CustomEvent(\"graph\", {\n            detail: initData.graph,\n            bubbles: true,\n            composed: true,\n            cancelable: true\n        }));\n        this.formMetaData = initData.args;\n        this.requestUpdate();\n    }\n    /**\n   * Renders the HTML template for the component.\n   * \n   * @returns {TemplateResult} The rendered HTML template.\n   */ render() {\n        console.debug(\"render\", this.formMetaData);\n        return (0, $800sp.html)`\n        <div class=\"container\">\n          ${Object.entries(this.formMetaData).map(([key, value])=>(0, $800sp.html)`<textarea id=\"${key}\" class=\"textarea textarea-primary\" placeholder=\"${key}\"></textarea>`)}\n          <button @click=\"${this.#submit}\" class=\"btn btn-primary\">Submit</button>\n        </div>\n    `;\n    }\n    async #submit() {\n        // console.debug( 'test', this.test )\n        if (this.test) {\n            setTimeout(()=>{\n                this.dispatchEvent(new CustomEvent(\"result\", {\n                    detail: {\n                        node: \"node1\",\n                        state: {\n                            property1: \"value1\",\n                            property2: \"value2\"\n                        }\n                    },\n                    bubbles: true,\n                    composed: true,\n                    cancelable: true\n                }));\n            }, 1000);\n            return;\n        }\n        const data = Object.keys(this.formMetaData).reduce((acc, key)=>{\n            acc[key] = this.shadowRoot.getElementById(key).value;\n            return acc;\n        }, {});\n        const execResponse = await fetch(`${this.url}/stream`, {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(data)\n        });\n        for await (let chunk of $0ca21e1f1d158660$var$streamingResponse(execResponse)){\n            console.debug(chunk);\n            this.dispatchEvent(new CustomEvent(\"result\", {\n                detail: JSON.parse(chunk),\n                bubbles: true,\n                composed: true,\n                cancelable: true\n            }));\n        }\n    }\n}\nwindow.customElements.define(\"lg4j-executor\", $0ca21e1f1d158660$export$2fe88ce002d9c04f);\n\n\n//# sourceMappingURL=index.4c99d4d4.js.map\n","import TWStyles from './twlit';\n\nimport { html, css, LitElement } from 'lit';\n\n/**\n * Asynchronously fetches data from a given fetch call and yields the data in chunks.\n * \n * @async\n * @generator\n * @param Response - Response object to stream.\n * @yields {Promise<string>} The decoded text chunk from the response stream.\n */\nasync function* streamingResponse(response) {\n  // Attach Reader\n  const reader = response.body.getReader();\n  while (true) {\n    // wait for next encoded chunk\n    const { done, value } = await reader.read();\n    // check if stream is done\n    if (done) break;\n    // Decodes data chunk and yields it\n    yield (new TextDecoder().decode(value));\n  }\n}\n\n/**\n * LG4JInputElement is a custom web component that extends LitElement.\n * It provides a styled input container with a placeholder.\n * \n * @class\n * @extends {LitElement}\n */\nexport class LG4JExecutorElement extends LitElement {\n\n  /**\n   * Styles applied to the component.\n   * \n   * @static\n   * @type {Array}\n   */\n  static styles = [TWStyles, css`\n    .container {\n      display: flex;\n      flex-direction: column;\n      row-gap: 10px;\n    }\n  `];\n\n  /**\n   * Properties of the component.\n   * \n   * @static\n   * @type {Object}\n   */\n  static properties = {\n    url: {},\n    test: { type: Boolean }\n  }\n\n  /**\n   * Creates an instance of LG4JInputElement.\n   * \n   * @constructor\n   */\n  constructor() {\n    super();\n    this.test = false\n    this.formMetaData = {}\n  }\n\n  /**\n   * Lifecycle method called when the element is added to the document's DOM.\n   */\n  connectedCallback() {\n    super.connectedCallback();\n\n    if(this.test ) {\n\n      setTimeout( () => {\n        \n          this.dispatchEvent( new CustomEvent( 'graph', { \n            detail: `\n            flowchart TD\n            Start --> Stop\n            `,\n            bubbles: true,\n            composed: true,\n            cancelable: true\n          }));\n\n          this.formMetaData = { \n            input: { type: 'string', required: true }\n          }\n          \n          this.requestUpdate()\n\n      }, 1000 );\n      \n    }\n    else {\n\n      this.#init()\n\n    }\n\n  }\n\n  async #init() {\n\n    const initResponse = await fetch( `${this.url}/init` )\n\n    const initData = await initResponse.json()\n    \n    console.debug( initData );\n\n    this.dispatchEvent( new CustomEvent( 'graph', { \n      detail: initData.graph,\n      bubbles: true,\n      composed: true,\n      cancelable: true\n    }));\n\n    this.formMetaData = initData.args\n    this.requestUpdate()\n  }\n\n  /**\n   * Renders the HTML template for the component.\n   * \n   * @returns {TemplateResult} The rendered HTML template.\n   */\n  render() {\n    console.debug( 'render', this.formMetaData )\n    return html`\n        <div class=\"container\">\n          ${ Object.entries(this.formMetaData).map( ([key,value]) => \n             html`<textarea id=\"${key}\" class=\"textarea textarea-primary\" placeholder=\"${key}\"></textarea>`\n          )}\n          <button @click=\"${this.#submit}\" class=\"btn btn-primary\">Submit</button>\n        </div>\n    `;\n  }\n\n  async #submit() {\n    // console.debug( 'test', this.test )\n    \n    if(this.test ) {\n\n      setTimeout( () => {\n\n          this.dispatchEvent( new CustomEvent( 'result', { \n            detail: { node: 'node1', state: { property1: \"value1\", property2: \"value2\" }},\n            bubbles: true,\n            composed: true,\n            cancelable: true\n          } ) );\n\n        }, 1000 );\n      \n      return\n    }\n    \n    const data = Object.keys(this.formMetaData).reduce( (acc, key) => {\n      acc[key] = this.shadowRoot.getElementById(key).value\n      return acc\n    }, {});\n\n    const execResponse = await fetch(`${this.url}/stream`, {\n        method: 'POST', // *GET, POST, PUT, DELETE, etc.\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(data)\n    });\n\n    for await (let chunk of streamingResponse( execResponse )  ) {\n      console.debug( chunk )\n\n      this.dispatchEvent( new CustomEvent( 'result', { \n        detail: JSON.parse(chunk),\n        bubbles: true,\n        composed: true,\n        cancelable: true\n      } ) );\n\n    }\n  }\n  \n}\n\n\nwindow.customElements.define('lg4j-executor', LG4JExecutorElement);\n"],"names":["$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","$hNeh9","$800sp","$0ca21e1f1d158660$var$streamingResponse","response","reader","body","getReader","done","value","read","TextDecoder","decode","$0ca21e1f1d158660$export$2fe88ce002d9c04f","LitElement","styles","default","css","properties","url","test","type","Boolean","constructor","formMetaData","connectedCallback","setTimeout","dispatchEvent","CustomEvent","detail","bubbles","composed","cancelable","input","required","requestUpdate","initResponse","fetch","initData","json","console","debug","graph","args","render","html","Object","entries","map","key","submit","node","state","property1","property2","data","keys","reduce","acc","shadowRoot","getElementById","chunk","method","headers","JSON","stringify","parse","window","customElements","define"],"version":3,"file":"index.4c99d4d4.js.map"}
{"mappings":"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","sources":["<anon>","src/lg4j-executor.js"],"sourcesContent":["\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire3bab\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire3bab\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\n\nvar $hNeh9 = parcelRequire(\"hNeh9\");\n\nvar $800sp = parcelRequire(\"800sp\");\n/**\n * Asynchronously waits for a specified number of milliseconds.\n * \n * @param {number} ms - The number of milliseconds to wait.\n * @returns {Promise<void>} A promise that resolves after the specified delay.\n */ const $0ca21e1f1d158660$var$delay = async (ms)=>new Promise((resolve)=>setTimeout(resolve, ms));\n/**\n * Asynchronously fetches data from a given fetch call and yields the data in chunks.\n * \n * @async\n * @generator\n * @param Response - Response object to stream.\n * @yields {Promise<string>} The decoded text chunk from the response stream.\n */ async function* $0ca21e1f1d158660$var$streamingResponse(response) {\n    // Attach Reader\n    const reader = response.body.getReader();\n    while(true){\n        // wait for next encoded chunk\n        const { done: done, value: value } = await reader.read();\n        // check if stream is done\n        if (done) break;\n        // Decodes data chunk and yields it\n        yield new TextDecoder().decode(value);\n    }\n}\nclass $0ca21e1f1d158660$export$2fe88ce002d9c04f extends (0, $800sp.LitElement) {\n    /**\n   * Styles applied to the component.\n   * \n   * @static\n   * @type {Array}\n   */ static styles = [\n        (0, $hNeh9.default),\n        (0, $800sp.css)`\n    .container {\n      display: flex;\n      flex-direction: column;\n      row-gap: 10px;\n    }\n  `\n    ];\n    /**\n   * Properties of the component.\n   * \n   * @static\n   * @type {Object}\n   */ static properties = {\n        url: {},\n        test: {\n            type: Boolean\n        }\n    };\n    /**\n   * Creates an instance of LG4JInputElement.\n   * \n   * @constructor\n   */ constructor(){\n        super();\n        this.test = false;\n        this.formMetaData = {};\n    }\n    /**\n   * Lifecycle method called when the element is added to the document's DOM.\n   */ connectedCallback() {\n        super.connectedCallback();\n        if (this.test) {\n            this.#init_test();\n            return;\n        }\n        this.#init();\n    }\n    async #init() {\n        const initResponse = await fetch(`${this.url}/init`);\n        const initData = await initResponse.json();\n        console.debug(\"initData\", initData);\n        this.dispatchEvent(new CustomEvent(\"init\", {\n            detail: initData,\n            bubbles: true,\n            composed: true,\n            cancelable: true\n        }));\n        this.formMetaData = initData.args;\n        this.requestUpdate();\n    }\n    async #init_test() {\n        await $0ca21e1f1d158660$var$delay(1000);\n        this.dispatchEvent(new CustomEvent(\"init\", {\n            detail: {\n                title: \"LangGraph4j : TEST\",\n                graph: `\nflowchart TD\n  start((start))\n  stop((stop))\n  node1(\"node1\")\n  node2(\"node2\")\n\n  start:::start --> node1:::node1\n  node1:::node1 --> node2:::node2\n  node2:::node2 --> stop:::stop\n      `\n            },\n            bubbles: true,\n            composed: true,\n            cancelable: true\n        }));\n        this.formMetaData = {\n            input: {\n                type: \"string\",\n                required: true\n            }\n        };\n        this.requestUpdate();\n    }\n    /**\n   * Renders the HTML template for the component.\n   * \n   * @returns {TemplateResult} The rendered HTML template.\n   */ render() {\n        console.debug(\"render\", this.formMetaData);\n        return (0, $800sp.html)`\n        <div class=\"container\">\n          ${Object.entries(this.formMetaData).map(([key, value])=>(0, $800sp.html)`<textarea id=\"${key}\" class=\"textarea textarea-primary\" placeholder=\"${key}\"></textarea>`)}\n          <button @click=\"${this.#submit}\" class=\"btn btn-primary\">Submit</button>\n        </div>\n    `;\n    }\n    async #submit() {\n        if (this.test) {\n            await this.#submit_test();\n            return;\n        }\n        const data = Object.keys(this.formMetaData).reduce((acc, key)=>{\n            acc[key] = this.shadowRoot.getElementById(key).value;\n            return acc;\n        }, {});\n        const execResponse = await fetch(`${this.url}/stream`, {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(data)\n        });\n        for await (let chunk of $0ca21e1f1d158660$var$streamingResponse(execResponse)){\n            console.debug(chunk);\n            this.dispatchEvent(new CustomEvent(\"result\", {\n                detail: JSON.parse(chunk),\n                bubbles: true,\n                composed: true,\n                cancelable: true\n            }));\n        }\n    }\n    async #submit_test() {\n        const send = async (nodeId)=>{\n            await $0ca21e1f1d158660$var$delay(1000);\n            this.dispatchEvent(new CustomEvent(\"result\", {\n                detail: {\n                    node: nodeId,\n                    state: {\n                        input: \"this is input\",\n                        property1: {\n                            value: \"value1\",\n                            valid: true\n                        },\n                        property2: {\n                            value: \"value2\",\n                            children: {\n                                elements: [\n                                    1,\n                                    2,\n                                    3\n                                ]\n                            }\n                        }\n                    }\n                },\n                bubbles: true,\n                composed: true,\n                cancelable: true\n            }));\n        };\n        await send(\"start\");\n        await send(\"node1\");\n        await send(\"node2\");\n        await send(\"stop\");\n    }\n}\nwindow.customElements.define(\"lg4j-executor\", $0ca21e1f1d158660$export$2fe88ce002d9c04f);\n\n\n//# sourceMappingURL=index.7d89dd1e.js.map\n","import TWStyles from './twlit';\n\nimport { html, css, LitElement } from 'lit';\n\n/**\n * Asynchronously waits for a specified number of milliseconds.\n * \n * @param {number} ms - The number of milliseconds to wait.\n * @returns {Promise<void>} A promise that resolves after the specified delay.\n */\nconst delay = async (ms) => (new Promise(resolve => setTimeout(resolve, ms)));\n\n/**\n * Asynchronously fetches data from a given fetch call and yields the data in chunks.\n * \n * @async\n * @generator\n * @param Response - Response object to stream.\n * @yields {Promise<string>} The decoded text chunk from the response stream.\n */\nasync function* streamingResponse(response) {\n  // Attach Reader\n  const reader = response.body.getReader();\n  while (true) {\n    // wait for next encoded chunk\n    const { done, value } = await reader.read();\n    // check if stream is done\n    if (done) break;\n    // Decodes data chunk and yields it\n    yield (new TextDecoder().decode(value));\n  }\n}\n\n/**\n * LG4JInputElement is a custom web component that extends LitElement.\n * It provides a styled input container with a placeholder.\n * \n * @class\n * @extends {LitElement}\n */\nexport class LG4JExecutorElement extends LitElement {\n\n  /**\n   * Styles applied to the component.\n   * \n   * @static\n   * @type {Array}\n   */\n  static styles = [TWStyles, css`\n    .container {\n      display: flex;\n      flex-direction: column;\n      row-gap: 10px;\n    }\n  `];\n\n  /**\n   * Properties of the component.\n   * \n   * @static\n   * @type {Object}\n   */\n  static properties = {\n    url: {},\n    test: { type: Boolean }\n  }\n\n  /**\n   * Creates an instance of LG4JInputElement.\n   * \n   * @constructor\n   */\n  constructor() {\n    super();\n    this.test = false\n    this.formMetaData = {}\n  }\n\n  /**\n   * Lifecycle method called when the element is added to the document's DOM.\n   */\n  connectedCallback() {\n    super.connectedCallback();\n\n    if(this.test ) {\n      this.#init_test();\n      return\n    }\n\n    this.#init()\n\n  }\n\n\n  async #init() {\n\n    const initResponse = await fetch( `${this.url}/init` )\n\n    const initData = await initResponse.json()\n    \n    console.debug( 'initData', initData );\n\n    this.dispatchEvent( new CustomEvent( 'init', { \n      detail: initData,\n      bubbles: true,\n      composed: true,\n      cancelable: true\n    }));\n\n    this.formMetaData = initData.args\n    this.requestUpdate()\n  }\n\n  async #init_test() {\n        \n    await delay( 1000 );\n    this.dispatchEvent( new CustomEvent( 'init', { \n      detail: { \n        title: 'LangGraph4j : TEST',\n        graph:`\nflowchart TD\n  start((start))\n  stop((stop))\n  node1(\"node1\")\n  node2(\"node2\")\n\n  start:::start --> node1:::node1\n  node1:::node1 --> node2:::node2\n  node2:::node2 --> stop:::stop\n      `\n      },\n      bubbles: true,\n      composed: true,\n      cancelable: true\n    }));\n\n    this.formMetaData = { \n      input: { type: 'string', required: true }\n    }\n    \n    this.requestUpdate()\n\n  }\n\n  /**\n   * Renders the HTML template for the component.\n   * \n   * @returns {TemplateResult} The rendered HTML template.\n   */\n  render() {\n    console.debug( 'render', this.formMetaData )\n    return html`\n        <div class=\"container\">\n          ${ Object.entries(this.formMetaData).map( ([key,value]) => \n             html`<textarea id=\"${key}\" class=\"textarea textarea-primary\" placeholder=\"${key}\"></textarea>`\n          )}\n          <button @click=\"${this.#submit}\" class=\"btn btn-primary\">Submit</button>\n        </div>\n    `;\n  }\n\n\n  async #submit() {\n    \n    if(this.test ) {\n      await this.#submit_test();\n      return\n    }\n    \n    const data = Object.keys(this.formMetaData).reduce( (acc, key) => {\n      acc[key] = this.shadowRoot.getElementById(key).value\n      return acc\n    }, {});\n\n    const execResponse = await fetch(`${this.url}/stream`, {\n        method: 'POST', // *GET, POST, PUT, DELETE, etc.\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(data)\n    });\n\n    for await (let chunk of streamingResponse( execResponse )  ) {\n      console.debug( chunk )\n\n      this.dispatchEvent( new CustomEvent( 'result', { \n        detail: JSON.parse(chunk),\n        bubbles: true,\n        composed: true,\n        cancelable: true\n      } ) );\n\n    }\n  }\n  \n  async #submit_test() {\n\n    const send = async ( nodeId ) => {\n      await delay( 1000 );\n      this.dispatchEvent( new CustomEvent( 'result', { \n        detail: { \n          node: nodeId, \n          state: { \n            input: \"this is input\",\n            property1: { value: \"value1\", valid: true } , \n            property2: { value: \"value2\", children: { elements: [1,2,3]} } }},\n        bubbles: true,\n        composed: true,\n        cancelable: true\n      }));\n    }\n\n    await send( 'start' );\n    await send( 'node1' );\n    await send( 'node2');\n    await send( 'stop' );\n\n  }\n\n}\n\n\nwindow.customElements.define('lg4j-executor', LG4JExecutorElement);\n"],"names":["$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","$hNeh9","$800sp","$0ca21e1f1d158660$var$delay","ms","Promise","resolve","setTimeout","$0ca21e1f1d158660$var$streamingResponse","response","reader","body","getReader","done","value","read","TextDecoder","decode","$0ca21e1f1d158660$export$2fe88ce002d9c04f","LitElement","styles","default","css","properties","url","test","type","Boolean","constructor","formMetaData","connectedCallback","init_test","initResponse","fetch","initData","json","console","debug","dispatchEvent","CustomEvent","detail","bubbles","composed","cancelable","args","requestUpdate","title","graph","input","required","render","html","Object","entries","map","key","submit","submit_test","data","keys","reduce","acc","shadowRoot","getElementById","chunk","method","headers","JSON","stringify","parse","send","nodeId","node","state","property1","valid","property2","children","elements","window","customElements","define"],"version":3,"file":"index.7d89dd1e.js.map"}